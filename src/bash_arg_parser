#!/bin/bash

set -eu

#####################
# Private functions #
#####################

declare -gr __bash_parse_add_short_opt_usage="Usage is '\${FUNCNAME[0]} <command> <opt_letter> <opt_name> [<help text>]'"

__bash_parse_die() {
    echo -e "$@" >&2
    exit 1
}

__bash_parse_die_required_arg() {
    local arg_name=$1
    local usage_text=$2

    echo "fatal: $arg_name required." >&2
    __bash_parse_die "Usage: $usage_text"
}

__bash_parse_die_file_must_exist() {
    local file_name=$1
    local usage_text=$2

    echo "fatal: file '$file_name' does not exist." >&2
    __bash_parse_die "Usage: $usage_text"
}

__bash_parse_check_opt_arg() {
    local arg=${1}

    # don't let it be empty or start with a '-',
    # because that is probably an option flag
    [ -n "${arg}" ] && ! [[ "${arg}" = -* ]]
}

__bash_parse_check_valid_bash_var_name() {
	local bash_var_name=$1
	local re='^[_a-zA-Z][_a-zA-Z0-9]*$'
	[[ "$bash_var_name" =~ $re ]]
}

__bash_parse_assert_defined() {
    local cmd_name=$1
    local func_that_should_have_been_called=$2
    local funcname=$3

    #BASH_LINENO[second from last] is the line number
    #of the caller of the public api
    if ! [ -v "$cmd_name" ]; then
        __bash_parse_die "$0: line ${BASH_LINENO[${#BASH_LINENO[@]} - 2]}: ($funcname) must call '$func_that_should_have_been_called' first to define command '${cmd_name##__bash_parse_cmd_}'"
    fi
}

__bash_parse_assert_short_opt() {
    local character=$1
    local funcname=$2

    if ! [ ${#character} -eq 1 ]; then
        __bash_parse_die "$0: line ${BASH_LINENO[2]}: ($funcname) must only provide a single letter for the short opt letter argument!\nOffending argument: '$character'"
    fi
}

__bash_parse_add_opt() {
    if [ $# -eq 5 ]; then
        local cmd_name=$1
        local opt_letter=$2
        local opt_name=$3
        local opt_required_or_optional=$4
        local funcname=$5
        local help_text=
    elif [ $# -eq 6 ]; then
        local cmd_name=$1
        local opt_letter=$2
        local opt_name=$3
        local help_text=$4
        local opt_required_or_optional=$5
        local funcname=$6
    else
        __bash_parse_die "INTERNAL ERROR! Wrong number of args passed to '${FUNCNAME[0]}'"
    fi

    __bash_parse_assert_defined "__bash_parse_cmd_$cmd_name" 'BAP_new_command()' "$funcname"
    __bash_parse_assert_short_opt "$opt_letter" "$funcname"
    if ! __bash_parse_check_valid_bash_var_name "$opt_name"; then
        __bash_parse_die "$0: line ${BASH_LINENO[1]}: ($funcname) must provide a valid Bash variable name for parameter <opt_name>\nOffending argument: '$opt_name'"        
    fi
    
    opt_letter=$(printf "%q" "$opt_letter")

    eval "__bash_parse_cmd_${cmd_name}_opts+=(\"\$opt_letter\" \"\$opt_name\" $opt_required_or_optional none)"

    [ -n "$help_text" ] && eval "__bash_parse_cmd_${cmd_name}_opts_help_text+="'"'$'\n''  -$opt_letter      $help_text"'
    true
}

__bash_opt_is_defined() {
    local cmd_name=$1
    local opt_name=$2

    eval "declare -n short_opt_array=__bash_parse_cmd_${cmd_name}_opts"
    # Var is set in eval
    # shellcheck disable=SC2154
    for ((i = 0; i < ${#short_opt_array[@]}; i += 4)); do
        local opt_text=${short_opt_array[i + 1]}
        [ "$opt_text" = "$opt_name" ] && return 0
    done
    return 1
}

__bash_opt_set_arg_type() {
    local cmd_name=$1
    local opt_name=$2
    local opt_arg_type=$3

    eval "declare -n short_opt_array=__bash_parse_cmd_${cmd_name}_opts"
    # Var is set in eval
    # shellcheck disable=SC2154
    for ((i = 0; i < ${#short_opt_array[@]}; i += 4)); do
        local opt_text=${short_opt_array[i + 1]}
        if [ "$opt_text" = "$opt_name" ]; then
            short_opt_array[i + 3]=$opt_arg_type
            return
        fi
    done
}

##############
# Public API #
##############

BAP_generate_parse_func() {
    [ $# -ne 1 ] && __bash_parse_die "$0: line ${BASH_LINENO[0]}: Usage is 'BAP_generate_parse_func <command>'"
    local name_of_command=$1

    __bash_parse_assert_defined "__bash_parse_cmd_$name_of_command" 'BAP_new_command()' "${FUNCNAME[0]}"

    local sub_cmd_name=$name_of_command
    local script=""
    local script_locals=""
    local eval_ret=""
    local getopts_str=":"
    local getopts_case_body=""
    local getopts_case_colon_body=""
    local check_for_req_args_body=""
    local check_opt_arg_type=""
    local usage_text="$sub_cmd_name"
    local required_argument_given=no
    
    declare -n create_help_option="__bash_parse_cmd_${name_of_command}_create_help_option"

    eval "local top_level_cmd=\"\$__bash_parse_cmd_${name_of_command}_top_level_cmd_name \""
    [ "$top_level_cmd" = " " ] && top_level_cmd=

    eval "declare -n short_opt_array=__bash_parse_cmd_${name_of_command}_opts"

    if [ "$create_help_option" = yes ]; then
        usage_text+=" -h"
        getopts_str+='h'
        getopts_case_body+="h) __bash_parse_die \"Usage: $top_level_cmd\$USAGE_TEXT_$sub_cmd_name\"; ;; "
    fi

    # Var is set in eval
    # shellcheck disable=SC2154
    for ((i = 0; i < ${#short_opt_array[@]}; i += 4)); do
        local opt_letter=${short_opt_array[i]}
        local opt_text=${short_opt_array[i + 1]}
        local opt_type=${short_opt_array[i + 2]}
        local opt_arg_type=${short_opt_array[i + 3]}
        
        script_locals+="local __var_$opt_text=; "
        eval_ret+="local $opt_text='\$__var_$opt_text'; "
        getopts_str+="$opt_letter:"
        getopts_case_body+="$opt_letter) __var_$opt_text=\$OPTARG; "
        getopts_case_body+="__bash_parse_check_opt_arg \"\$__var_$opt_text\" || "
        getopts_case_body+="__bash_parse_die_required_arg '<$opt_text>' \"$top_level_cmd \$USAGE_TEXT_$sub_cmd_name\";; "

        getopts_case_colon_body+="$opt_letter) "
        getopts_case_colon_body+="__bash_parse_die_required_arg '<$opt_text>' \"$top_level_cmd\$USAGE_TEXT_$sub_cmd_name\";; "

        case "$opt_type" in
            required) 
                required_argument_given=yes
                usage_text+=" -$opt_letter <$opt_text>"

                check_for_req_args_body+="[ -z \"\$__var_$opt_text\" ] && "
                check_for_req_args_body+="__bash_parse_die_required_arg '<$opt_text>' \"$top_level_cmd\$USAGE_TEXT_$sub_cmd_name\"; "
                ;;
            optional)
                usage_text+=" [-$opt_letter <$opt_text>]"
                ;;
            *)
                __bash_parse_die "INTERNAL ERROR: (${FUNCNAME[0]}) invalid opt_type of '$opt_type'"
                ;;
        esac
        case "$opt_arg_type" in
            none)
                ;;
            existent_file)
                if [ "$opt_type" = optional ]; then
                    check_opt_arg_type+="if [ -n \"\$__var_$opt_text\" ]; then [ -e \"\$__var_$opt_text\" ] || "
                    check_opt_arg_type+="__bash_parse_die_file_must_exist \"\$__var_$opt_text\" \"$top_level_cmd\$USAGE_TEXT_$sub_cmd_name\"; fi; "
                else
                    check_opt_arg_type+="[ -e \"\$__var_$opt_text\" ] || "
                    check_opt_arg_type+="__bash_parse_die_file_must_exist \"\$__var_$opt_text\" \"$top_level_cmd\$USAGE_TEXT_$sub_cmd_name\"; "
                fi
                ;;
            *)
                __bash_parse_die "INTERNAL ERROR: (${FUNCNAME[0]}) invalid opt_type of '$opt_arg_type'"
                ;;
        esac
    done

    # Now construct the usage text declaration, 
    # the parser function definition,
    # and the body of the function

    # It'll look something like:

    : << EOM
    declare -r USAGE_TEXT_foo=...
    parse_foo_args() {
        local arg_a=
        local arg_b=
        while getopts ':a:b:' opt; do
            case \$opt in
                a)
                    a=\$OPTARG
                    make_sure_var_exists
                ...
                :)
                    handle cases where no arg was given to an option
        done

        handle_making_sure_we_got_all_required_args
    }
EOM
        
    # Remeber that you can use the 'type' command
    # in your program after calling 'BAP_generate_parser()'
    # to have Bash pretty-print the resuling function`
    # if you are curious :)
    # see examples/type_example

    eval_ret+="shift \$((OPTIND - 1)); "
    
    script+="declare -gr USAGE_TEXT_$sub_cmd_name=\"$usage_text\"; "

    declare -n opts_help_text="__bash_parse_cmd_${sub_cmd_name}_opts_help_text"
    if [ "$create_help_option" = yes ] && [ -n "$opts_help_text" ]; then
        script+="declare -gr OPT_USAGE_TEXT_$sub_cmd_name=\"$opts_help_text\"; "
    else
        script+="declare -gr OPT_USAGE_TEXT_$sub_cmd_name=;"
    fi

    script+="parse_${sub_cmd_name}_args() { "
    script+=$script_locals

    if [ "$required_argument_given" = yes ]; then
        script+="[ \$# -eq 0 ] && __bash_parse_die \"Usage: $top_level_cmd\$USAGE_TEXT_$sub_cmd_name\"; "
    fi
    script+="while getopts '$getopts_str' opt; do case \$opt in "
    script+=$getopts_case_body 
    script+=":) case \$OPTARG in $getopts_case_colon_body esac;; "
    script+="\\?) __bash_parse_die \"Unsupported option: -\$OPTARG\";; esac; done; "
    script+=$check_for_req_args_body
    script+=$check_opt_arg_type
    script+="echo \"$eval_ret\"; "
    script+="}"

    eval "$script"
}

BAP_new_command() {
    local usage="Usage is '${FUNCNAME[0]} <new_command>'"
    [ $# -ne 1 ] && __bash_parse_die "$0: line ${BASH_LINENO[0]}: $usage"
    local cmd_name=$1
	
	if ! __bash_parse_check_valid_bash_var_name "$cmd_name"; then
        __bash_parse_die "$0: line ${BASH_LINENO[0]}: must provide a valid Bash variable name for parameter <new_command>\nOffending argument: '$cmd_name'"
    fi

    # Just define this variable
    declare -gr __bash_parse_cmd_"${cmd_name}"=
    declare -g __bash_parse_cmd_"${cmd_name}"_top_level_cmd_name=
    declare -g __bash_parse_cmd_"${cmd_name}"_opts_help_text=
    declare -g __bash_parse_cmd_"${cmd_name}"_create_help_option=no
    eval "declare -g __bash_parse_cmd_${cmd_name}_opts=()"
}

BAP_set_top_level_cmd_name() {
    local usage="Usage is '${FUNCNAME[0]} <command> <top level cmd name>'"
    [ $# -ne 2 ] && __bash_parse_die "$0: line ${BASH_LINENO[0]}: $usage"
    local cmd_name=$1
    # Var is used in eval
    # shellcheck disable=SC2034
    local top_level_cmd_name=$2
    
    local top_level_cmd_name_hash
    
    __bash_parse_assert_defined "__bash_parse_cmd_$cmd_name" 'BAP_new_command()' "${FUNCNAME[0]}"
    
    eval "__bash_parse_cmd_${cmd_name}_top_level_cmd_name=\$top_level_cmd_name"

    # We need to hash the name to create a valid Bash variable name in case of invalid characters
    top_level_cmd_name_hash="$(md5sum <<< "$top_level_cmd_name" | awk '{print $1}')"

    eval "__bash_parse_cmd_top_level_cmd_${top_level_cmd_name_hash}_sub_commands+=(\$cmd_name)"
}

BAP_generate_top_level_cmd_parser() {
    local usage="Usage is '${FUNCNAME[0]} <top level cmd name>"
    [ $# -ne 1 ] && __bash_parse_die "$0: line ${BASH_LINENO[0]}: $usage"
    local top_level_cmd_name=$1

    local top_level_cmd_name_hash

    top_level_cmd_name_hash="$(md5sum <<< "$top_level_cmd_name" | awk '{print $1}')"

    if ! [ -v "__bash_parse_cmd_top_level_cmd_${top_level_cmd_name_hash}_sub_commands" ]; then
        __bash_parse_die  "$0: line ${BASH_LINENO[0]}: must call 'BAP_set_top_level_cmd_name()' with a second argument of '$top_level_cmd_name' first!"
    fi

    local script=
    local help_text=
    local case_body=
    local opt_help_text=Options:

    declare -n sub_cmd_array="__bash_parse_cmd_top_level_cmd_${top_level_cmd_name_hash}_sub_commands"
    for sub_cmd in "${sub_cmd_array[@]}"; do
        if ! [ -v "USAGE_TEXT_$sub_cmd" ]; then
            __bash_parse_die  "$0: line ${BASH_LINENO[0]}: must call 'BAP_generate_parse_func()' with a second argument of '$sub_cmd' first!"
        fi
        eval "help_text+=\"  $top_level_cmd_name \$USAGE_TEXT_${sub_cmd}\"$'\n'"
        eval "if [ -n \"\$OPT_USAGE_TEXT_${sub_cmd}\" ]; then opt_help_text+=\$OPT_USAGE_TEXT_${sub_cmd}$'\n'; else true; fi"
        case_body+="$sub_cmd) shift; $sub_cmd \"\$@\";; "
    done

    help_text=$help_text$'\n'$opt_help_text
    case_body+="*) echo '$help_text' && exit 1"

    script+="parse_top_level_args() { "
    script+="[ \$# -eq 0 ] && echo $'Usage:\n$help_text' && exit 1;"
    script+="case \"\$1\" in $case_body esac"
    script+=" }"
    echo "$script"
    eval "$script"
}

BAP_add_required_short_opt() {
    if [ $# -ne 3 ] && [ $# -ne 4 ]; then
        __bash_parse_die "$(eval "echo -n \"\$0: line \${BASH_LINENO[0]}: $__bash_parse_add_short_opt_usage\"")"
    fi
    __bash_parse_add_opt "$@" required "${FUNCNAME[0]}"
}

BAP_add_optional_short_opt() {
    if [ $# -ne 3 ] && [ $# -ne 4 ]; then
        __bash_parse_die "$(eval "echo -n \"\$0: line \${BASH_LINENO[0]}: $__bash_parse_add_short_opt_usage\"")"
    fi
    __bash_parse_add_opt "$@" optional "${FUNCNAME[0]}"
}

BAP_set_opt_arg_type() {
    if [ $# -ne 3 ]; then
        __bash_parse_die "$(eval "echo -n \"\$0: line \${BASH_LINENO[0]}: Usage is 'BAP_set_opt_arg_type <command> <opt_name> <opt_arg_type>'\"")"
    fi

    local cmd_name=$1
    local opt_text=$2
    local opt_arg_type=$3

    __bash_parse_assert_defined "__bash_parse_cmd_$cmd_name" 'BAP_new_command()' "${FUNCNAME[0]}"

    eval "declare -n short_opt_array=__bash_parse_cmd_${cmd_name}_opts"

    __bash_opt_is_defined "$cmd_name" "$opt_text" || \
        __bash_parse_die "$0: line ${BASH_LINENO[0]}: must call 'BAP_add_optional_short_opt()' or 'BAP_add_required_short_opt()' to define option '$opt_text'"

    case "$opt_arg_type" in
        existent_file)
            ;;
        *)
            __bash_parse_die "$0: line ${BASH_LINENO[0]}: opt arg type must be one of: [existent_file]"
            ;;
    esac

    __bash_opt_set_arg_type "$cmd_name" "$opt_text" "$opt_arg_type"

}

BAP_create_help_option() {
    local usage="Usage is '${FUNCNAME[0]} <command>'"
    [ $# -ne 1 ] && __bash_parse_die "$0: line ${BASH_LINENO[0]}: $usage"
    local cmd_name=$1
    
    __bash_parse_assert_defined "__bash_parse_cmd_$cmd_name" 'BAP_new_command()' "${FUNCNAME[0]}"
    
    eval "__bash_parse_cmd_${cmd_name}_create_help_option=yes"
}
